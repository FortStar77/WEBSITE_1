<!DOCTYPE html>
<html lang="en" data-theme="light"> <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ReflexCore - Professional Aim and Reaction Trainer</title>
    <meta name="description" content="Improve your reaction time, accuracy, and typing speed. Train in multiple game modes: Aim Trainer, Tracking, Typing Test, Memory Game, and Whac-a-Mole.">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    
    <style>
        /* ======================================================================= */
        /* 1. GLOBAL CSS VARIABLES AND RESET                                     */
        /* ======================================================================= */

        :root {
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            --transition-speed: 0.3s;
            
            /* Dynamic game variables (controlled by JS/Settings) */
            --target-size: 50px;
            --target-color: #FF4136; /* Red */
            --target-color-hover: #FF7066;
        }

        /* --- Light Theme (Default) --- */
        [data-theme="light"] {
            --bg-color: #F8F9FA;
            --bg-color-secondary: #FFFFFF;
            --text-color: #212529;
            --text-color-muted: #6C757D;
            --border-color: #DEE2E6;
            --accent-color: #007BFF;
            --accent-color-hover: #0056b3;
            --danger-color: #DC3545;
            --danger-color-hover: #a71d2a;
            --success-color: #28A745;
        }

        /* --- Dark Theme --- */
        [data-theme="dark"] {
            --bg-color: #121212;
            --bg-color-secondary: #1E1E1E;
            --text-color: #E0E0E0;
            --text-color-muted: #8E8E8E;
            --border-color: #333333;
            --accent-color: #0D6EFD;
            --accent-color-hover: #3D8BFF;
            --danger-color: #FF4136;
            --danger-color-hover: #FF7066;
            --success-color: #198754;
        }

        /* --- Global Reset --- */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            transition: background-color var(--transition-speed), color var(--transition-speed);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        h1, h2, h3, h4, h5, h6 {
            margin-bottom: 0.75rem;
            line-height: 1.2;
        }

        a {
            color: var(--accent-color);
            text-decoration: none;
            transition: color var(--transition-speed);
        }

        a:hover {
            color: var(--accent-color-hover);
            text-decoration: underline;
        }

        img {
            max-width: 100%;
            height: auto;
            display: block;
        }

        button,
        select,
        input {
            font-family: inherit;
            font-size: 1rem;
            color: inherit;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 0.5rem 0.75rem;
            background-color: var(--bg-color-secondary);
            transition: all var(--transition-speed);
        }

        button:hover {
            cursor: pointer;
        }

        .btn {
            border: none;
            color: #FFFFFF;
            background-color: var(--accent-color);
            font-weight: bold;
        }
        .btn:hover {
            background-color: var(--accent-color-hover);
        }
        .btn-danger {
            background-color: var(--danger-color);
        }
        .btn-danger:hover {
            background-color: var(--danger-color-hover);
        }
        .icon-btn {
            background: none;
            border: none;
            padding: 0.5rem;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .icon-btn:hover {
            background-color: var(--border-color);
        }
        .icon-btn svg {
            width: 24px;
            height: 24px;
            fill: var(--text-color);
        }

        /* ======================================================================= */
        /* 2. PAGE LAYOUT (HEADER, NAV, MAIN, SIDEBAR, FOOTER)                     */
        /* ======================================================================= */

        /* --- Header --- */
        .main-header {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            background-color: var(--bg-color-secondary);
            border-bottom: 2px solid var(--border-color);
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .logo {
            font-size: 2rem;
            font-weight: 800;
            color: var(--text-color);
        }
        .logo-accent {
            color: var(--accent-color);
        }
        .settings-toggle-container {
            display: flex;
            align-items: center;
        }

        /* --- Navigation --- */
        .main-nav {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5rem;
            padding: 1rem;
            background-color: var(--bg-color-secondary);
            border-bottom: 1px solid var(--border-color);
        }
        .nav-btn {
            border: none;
            background: none;
            padding: 0.5rem 1rem;
            font-weight: 600;
            color: var(--text-color-muted);
            border-radius: 5px;
        }
        .nav-btn:hover {
            background-color: var(--border-color);
            color: var(--text-color);
        }
        .nav-btn.active {
            background-color: var(--accent-color);
            color: #FFFFFF;
        }

        /* --- Main App Layout (Grid) --- */
        .app-container {
            display: grid;
            /* Defining 3 columns: Settings (auto), Content (1fr), Sidebar (auto) */
            grid-template-columns: auto 1fr auto;
            width: 100%;
            max-width: 1600px;
            margin: 1rem auto;
            padding: 0 1rem;
            gap: 1rem;
            flex-grow: 1;
        }

        /* --- Settings Panel --- */
        .settings-panel {
            grid-column: 1 / 2;
            background-color: var(--bg-color-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            width: 280px;
            align-self: start; /* Stick to top */
            transition: all 0.3s ease-in-out;
        }
        /* Show/hide logic */
        .settings-panel[hidden] {
            display: block!important; /* Allow animation */
            transform: translateX(-100%);
            opacity: 0;
            width: 0;
            padding: 1rem 0;
            margin-right: -1rem; /* Compensate 'gap' */
        }
        .settings-panel.open {
            transform: translateX(0);
            opacity: 1;
            width: 280px;
            padding: 1rem;
            margin-right: 0;
        }
        .settings-title,.settings-subtitle {
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
        }
        .settings-subtitle {
            font-size: 1.1rem;
            margin-top: 1rem;
        }
        .setting-group {
            margin-bottom: 1.25rem;
        }
        .setting-label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
        .setting-select,.setting-slider,.setting-color-picker {
            width: 100%;
        }
        .setting-color-picker {
            height: 40px;
            padding: 0.25rem;
            border: 1px solid var(--border-color);
        }

        /* --- Theme Toggle Switch --- */
        .toggle-switch {
            position: relative;
            width: 100px;
            height: 40px;
        }
        .toggle-input {
            display: none;
        }
        .toggle-label {
            display: block;
            width: 100px;
            height: 40px;
            background-color: var(--bg-color-secondary);
            border: 2px solid var(--border-color);
            border-radius: 20px;
            cursor: pointer;
            position: relative;
            transition: all var(--transition-speed);
        }
        .toggle-label::before {
            content: '';
            display: block;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: var(--accent-color);
            position: absolute;
            top: 2px;
            left: 4px;
            transition: all var(--transition-speed) ease-in-out;
        }
        .toggle-text-light,.toggle-text-dark {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.8rem;
            font-weight: bold;
        }
        .toggle-text-light {
            left: 10px;
            color: var(--text-color);
        }
        .toggle-text-dark {
            right: 10px;
            color: var(--text-color-muted);
        }
        /* "Dark" state (checked) */
        .toggle-input:checked +.toggle-label {
            background-color: var(--bg-color-secondary);
        }
        .toggle-input:checked +.toggle-label::before {
            transform: translateX(60px); /* Move the knob */
            background-color: var(--accent-color);
        }
        .toggle-input:checked +.toggle-label .toggle-text-light {
            color: var(--text-color-muted);
        }
        .toggle-input:checked +.toggle-label .toggle-text-dark {
            color: var(--text-color);
        }


        /* --- Main Content --- */
        .main-content {
            grid-column: 2 / 3;
            background-color: var(--bg-color-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 2rem;
            min-height: 70vh;
        }
        .game-screen {
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
        }
        .game-screen.active {
            display: flex; /* Show only active screen */
        }
        .game-title,.game-subtitle {
            text-align: center;
        }
        .game-description {
            text-align: center;
            font-size: 1.1rem;
            color: var(--text-color-muted);
            margin-bottom: 1.5rem;
        }
        .high-scores {
            width: 100%;
            max-width: 400px;
            margin-top: 1rem;
        }

        /* --- Sidebar --- */
        .sidebar {
            grid-column: 3 / 4;
            background-color: var(--bg-color-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            width: 200px;
            align-self: start;
        }
        .widget-title {
            font-size: 1.2rem;
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }
        .stat-label {
            font-weight: 600;
            color: var(--text-color-muted);
        }
        .stat-value {
            font-weight: bold;
        }

        /* --- Footer --- */
        .main-footer {
            width: 100%;
            padding: 2rem;
            margin-top: auto; /* Pushes footer to bottom */
            text-align: center;
            background-color: var(--bg-color-secondary);
            border-top: 1px solid var(--border-color);
            font-size: 0.9rem;
            color: var(--text-color-muted);
        }

        /* ======================================================================= */
        /* 3. ADVERTISEMENT STYLES (KEY FOR COMPLIANCE)                         */
        /* ======================================================================= */

        .ad-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--bg-color);
            border: 1px dashed var(--border-color);
            min-height: 50px;
            margin: 1rem 0;
        }
        
        /* "Advertisement" label
           This is a Google AdSense REQUIREMENT to clearly separate ads.
        */
        .ad-label {
            position: absolute;
            top: -1px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--border-color);
            color: var(--text-color-muted);
            padding: 2px 8px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            border-radius: 0 0 5px 5px;
            z-index: 1;
        }

        .ad-placeholder-text {
            font-size: 0.9rem;
            color: var(--text-color-muted);
            font-weight: 500;
        }

        /* Styles for specific slots */
        .header-ad-container {
            display: flex;
            gap: 1rem;
        }
        .ad-container-top-banner {
            width: 300px; 
            height: 50px;
            margin: 0; 
        }
        .ad-container-google-middle {
            width: 100%;
            max-width: 336px;
            min-height: 280px;
            margin: 2rem auto; 
        }
        .ad-container-sidebar {
            width: 100%;
            min-height: 250px; 
        }

        /* ======================================================================= */
        /* 4. MODAL STYLES (DIALOGS)                                               */
        /* ======================================================================= */

        .modal {
            border: none;
            border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            padding: 0; 
            width: 90%;
            max-width: 500px;
            background: var(--bg-color-secondary);
            color: var(--text-color);
        }
        .modal::backdrop {
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(3px);
        }
        .modal-content {
            padding: 1.5rem;
            position: relative;
        }
        .modal-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 2rem;
            font-weight: bold;
            color: var(--text-color-muted);
            padding: 0 0.5rem;
        }
        .modal-close-btn:hover {
            color: var(--danger-color);
        }
        .modal-title {
            font-size: 1.8rem;
            margin-bottom: 1rem;
            color: var(--accent-color);
        }
        .modal-body {
            margin-bottom: 1.5rem;
        }
        .modal-body p {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }
        .modal-footer {
            display: flex;
            justify-content: flex-end;
        }
        .new-highscore {
            color: var(--success-color);
            text-align: center;
            font-size: 1.3rem;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* Special ad modal styles */
        .modal-ad .modal-content {
            padding: 0;
        }
        .modal-ad .modal-title {
            text-align: center;
            font-size: 1rem;
            padding: 0.5rem;
            background: var(--bg-color);
            margin-bottom: 0;
            color: var(--text-color-muted);
        }
        .modal-ad .modal-body {
            padding: 1rem;
            margin-bottom: 0;
        }
        .modal-ad .ad-container {
            margin: 0;
            border: none;
            background: none;
        }
        .modal-ad .ad-sub-text {
            font-size: 0.9rem;
            text-align: center;
            color: var(--text-color-muted);
            margin-top: 1rem;
            margin-bottom: 0;
        }


        /* ======================================================================= */
        /* 5. GAME MODE STYLES (AIM TRAINER, TYPING, MEMORY...)                    */
        /* ======================================================================= */

        /* --- Game Container --- */
        .game-area {
            width: 100%;
            height: 60vh;
            min-height: 400px;
            background-color: var(--bg-color);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            cursor: crosshair;
            user-select: none;
        }
        .game-start-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 2rem;
            text-align: center;
        }
        .game-start-screen .game-title {
            color: var(--accent-color);
        }
        .game-start-screen .btn {
            font-size: 1.5rem;
            padding: 1rem 2rem;
            margin-top: 1rem;
        }

        /* --- Target (Aim Trainer & Tracking) --- */
        .target {
            width: var(--target-size);
            height: var(--target-size);
            background-color: var(--target-color);
            border-radius: 50%;
            position: absolute;
            cursor: crosshair;
            transition: transform 0.1s ease-out, background-color 0.1s;
            box-shadow: 0 0 15px var(--target-color);
        }
        .target:hover {
            background-color: var(--target-color-hover);
            transform: scale(1.1);
        }

        /* --- Typing Test --- */
        .typing-test-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .typing-stats {
            display: flex;
            justify-content: space-around;
            padding: 1rem;
            background-color: var(--bg-color);
            border-radius: 8px;
        }
        .typing-stat-item {
            text-align: center;
        }
        .typing-stat-label {
            font-size: 0.9rem;
            color: var(--text-color-muted);
        }
        .typing-stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--accent-color);
        }
        .typing-text-display {
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.5rem;
            line-height: 2;
            padding: 1.5rem;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            height: 250px;
            overflow-y: auto;
            user-select: none;
        }
        .typing-text-display span {
            transition: color 0.1s, background-color 0.1s;
        }
        .typing-text-display span.correct {
            color: var(--success-color);
        }
        .typing-text-display span.incorrect {
            color: var(--danger-color);
            background-color: rgba(220, 53, 69, 0.1);
            text-decoration: underline;
        }
        .typing-text-display span.current {
            background-color: var(--accent-color);
            color: #FFFFFF;
            border-radius: 2px;
        }
        .typing-input-area {
            width: 100%;
            font-size: 1.5rem;
            font-family: 'Courier New', Courier, monospace;
            padding: 1rem;
            border: 2px solid var(--accent-color);
        }
        .typing-input-area:focus {
            outline: none;
            box-shadow: 0 0 10px var(--accent-color);
        }
        .typing-restart-btn {
            font-size: 1.2rem;
            padding: 0.75rem 1.5rem;
            align-self: center;
        }

        /* --- Memory Game --- */
        .memory-game-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
            perspective: 1000px; /* For 3D effect */
        }
        .memory-card {
            width: 100%;
            aspect-ratio: 1 / 1;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            cursor: pointer;
        }
        .memory-card.flip {
            transform: rotateY(180deg);
        }
        .memory-card .front-face,
        .memory-card .back-face {
            width: 100%;
            height: 100%;
            position: absolute;
            backface-visibility: hidden;  
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .memory-card .front-face {
            background-color: var(--bg-color-secondary);
            border: 2px solid var(--border-color);
            color: var(--text-color);
            transform: rotateY(180deg);
        }
        .memory-card .back-face {
            background: linear-gradient(135deg, var(--accent-color), var(--accent-color-hover));
            color: #FFFFFF;
            font-weight: bold;
        }

        /* --- Whac-a-Mole Game --- */
        .whac-game-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            width: 100%;
            max-width: 450px;
            margin: 2rem auto;
        }
        .whac-hole {
            width: 100%;
            aspect-ratio: 1 / 1;
            background-color: #A0522D; /* Dirt color */
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            border: 10px solid #8B4513;
            box-shadow: inset 0 10px 10px rgba(0,0,0,0.3);
        }
        .whac-mole {
            width: 70%;
            height: 70%;
            background-color: #D2B48C; /* Mole color */
            border: 3px solid #000;
            border-radius: 50%;
            position: absolute;
            bottom: 0;
            left: 15%;
            transition: transform 0.2s ease-out;
            transform: translateY(100%); /* Hidden */
            cursor: pointer;
        }
        .whac-hole.up .whac-mole {
            transform: translateY(0); /* Popped up */
        }


        /* ======================================================================= */
        /* 6. RESPONSIVE WEB DESIGN (RWD)                                          */
        /* ======================================================================= */

        @media (max-width: 1200px) {
           .app-container {
                /* Move sidebar below content if settings are open */
                grid-template-columns: auto 1fr;
           }
           .sidebar {
                grid-column: 1 / 3; /* Full width */
                grid-row: 3 / 4; /* Below content */
                width: 100%;
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 1rem;
           }
           .ad-container-sidebar {
                /* Change Skyscraper to a more suitable format */
                min-height: 250px;  
           }
           .main-content {
                /* If settings are open */
                grid-column: 2 / 3;
           }
           .main-content.full-width {
                /* If settings are closed */
                grid-column: 1 / 3;
           }
        }

        @media (max-width: 768px) {
           .app-container {
                /* Settings and content in one column */
                grid-template-columns: 1fr;
                margin: 0.5rem auto;
                padding: 0 0.5rem;
           }
           .settings-panel {
                grid-column: 1 / 2;
                grid-row: 1 / 2;
                width: 100%;
                /* Hide/Show on mobile */
                max-height: 0;
                padding: 0 1rem;
                border: none;
                overflow: hidden;
                opacity: 0;
                transform: translateY(-20px);
                transition: all 0.3s ease-in-out;
           }
           .settings-panel.open {
                max-height: 1000px; /* Enough */
                padding: 1rem;
                opacity: 1;
                transform: translateY(0);
                border: 1px solid var(--border-color);
           }
           .main-content,.main-content.full-width {
                grid-column: 1 / 2;
                grid-row: 2 / 3;
                padding: 1rem;
                min-height: 60vh;
           }
           .sidebar {
                grid-column: 1 / 2;
                grid-row: 3 / 4;
                grid-template-columns: 1fr; /* Stats and ad one below the other */
           }
           .main-header {
                padding: 1rem;
                flex-direction: column;
                gap: 1rem;
           }
           .header-ad-container {
                width: 100%;
                justify-content: center;
           }
            
           /* CRITICAL ADSENSE COMPLIANCE RULE
              Google policy recommends only one ATF unit on mobile.
              We hide one of the two header ads to maintain compliance.
           */
           #ad-header-top-right {
                display: none;
           }
           .ad-container-top-banner {
                width: 100%;
                max-width: 320px;
           }
            
           .main-nav {
                /* Allow buttons to wrap and center */
                gap: 0.25rem;
                padding: 0.5rem;
           }
           .nav-btn {
                font-size: 0.85rem;
                padding: 0.5rem 0.75rem;
           }
            
           .modal {
                width: 95%;
           }
            
           .game-area {
                min-height: 300px;
                height: 50vh;
           }
            
           .memory-game-grid {
                gap: 5px;
           }
           .whac-game-grid {
                gap: 10px;
           }
        }  
    </style>

</head>
<body>

    <header class="main-header">
        <div class="logo-container">
            <h1 class="logo">Reflex<span class="logo-accent">Core</span></h1>
        </div>
        
        <div class="header-ad-container">
            <div id="ad-header-top-left" class="ad-container ad-container-top-banner">
                <div class="ad-label">Advertisement</div>
                <div class="ad-placeholder-text"></div>
            </div>
            
            <div id="ad-header-top-right" class="ad-container ad-container-top-banner">
                <div class="ad-label">Advertisement</div>
                <div class="ad-placeholder-text"></div>
            </div>
        </div>
        
        <div class="settings-toggle-container">
            <button id="settings-toggle-btn" class="icon-btn" aria-label="Open settings">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M19.826 12.0001C19.826 13.3854 19.4533 14.7127 18.7613 15.8642L20.552 17.6549C20.7473 17.8502 20.7473 18.1668 20.552 18.362L19.138 19.776C18.9427 19.9713 18.6261 19.9713 18.4308 19.776L16.6117 17.9568C15.5393 18.5714 14.321 18.9664 13.0001 19.0833V21.0963C13.0001 21.3745 12.7762 21.5984 12.498 21.5984L11.5022 21.5984C11.224 21.5984 11.0001 21.3745 11.0001 21.0963V19.0833C9.67916 18.9664 8.46089 18.5714 7.38848 17.9568L5.56937 19.776C5.37407 19.9713 5.05748 19.9713 4.86218 19.776L3.44818 18.362C3.25288 18.1668 3.25288 17.8502 3.44818 17.6549L5.23889 15.8642C4.54694 14.7127 4.1742 13.3854 4.1742 12.0001C4.1742 10.6147 4.54694 9.28746 5.23889 8.13592L3.44818 6.34521C3.25288 6.14991 3.25288 5.83332 3.44818 5.63802L4.86218 4.22402C5.05748 4.02872 5.37407 4.02872 5.56937 4.22402L7.38848 6.04313C8.46089 5.42854 9.67916 5.03357 11.0001 5.00013V2.90381C11.0001 2.62564 11.224 2.40173 11.5022 2.40173L12.498 2.40173C12.7762 2.40173 13.0001 2.62564 13.0001 2.90381V5.00013C14.321 5.03357 15.5393 5.42854 16.6117 6.04313L18.4308 4.22402C18.6261 4.02872 18.9427 4.02872 19.138 4.22402L20.552 5.63802C20.7473 5.83332 20.7473 6.14991 20.552 6.34521L18.7613 8.13592C19.4533 9.28746 19.826 10.6147 19.826 12.0001ZM12.0001 15.5C13.9331 15.5 15.5001 13.933 15.5001 12C15.5001 10.067 13.9331 8.5 12.0001 8.5C10.0671 8.5 8.50008 10.067 8.50008 12C8.50008 13.933 10.0671 15.5 12.0001 15.5Z"></path></svg>
            </button>
        </div>
    </header>

    <nav class="main-nav">
        <button class="nav-btn active" data-game="aimTrainer">Aim Trainer</button>
        <button class="nav-btn" data-game="tracking">Tracking</button>
        <button class="nav-btn" data-game="typingTest">Typing Test (WPM)</button>
        <button class="nav-btn" data-game="memoryGame">Memory Game</button>
        <button class="nav-btn" data-game="whacAMole">Whac-a-Mole</button>
        <button class="nav-btn" data-section="blog">Blog / Guides</button>
        <button class="nav-btn" data-section="faq">FAQ</button>
    </nav>

    <div class="app-container">
    
        <aside id="settings-panel" class="settings-panel" hidden>
            <h2 class="settings-title">Settings</h2>
            
            <div class="setting-group">
                <label for="theme-toggle" class="setting-label">Site Theme</label>
                <div class="toggle-switch">
                    <input type="checkbox" id="theme-toggle" class="toggle-input">
                    <label for="theme-toggle" class="toggle-label">
                        <span class="toggle-text-light">Light</span>
                        <span class="toggle-text-dark">Dark</span>
                    </label>
                </div>
            </div>
            
            <div class="setting-group">
                <label for="language-select" class="setting-label">Language</label>
                <select id="language-select" class="setting-select">
                    <option value="pl">Polski</option>
                    <option value="en" selected>English</option>
                </select>
            </div>
            
            <hr class="settings-divider">
            <h3 class="settings-subtitle">Game Settings (Aim Trainer)</h3>
            
            <div class="setting-group">
                <label for="target-size-slider" class="setting-label">Target Size: <span id="target-size-value">50</span>px</label>
                <input type="range" id="target-size-slider" class="setting-slider" min="10" max="100" value="50" data-css-var="--target-size">
            </div>
            
            <div class="setting-group">
                <label for="target-color-picker" class="setting-label">Target Color</label>
                <input type="color" id="target-color-picker" class="setting-color-picker" value="#FF4136" data-css-var="--target-color">
            </div>
            
            <div class="setting-group">
                <button id="reset-stats-btn" class="btn btn-danger">Reset High Scores</button>
            </div>
            
        </aside>

        <main id="main-content" class="main-content">
        
            <div id="welcome-screen" class="game-screen active">
                <h2 class="game-title">Welcome to ReflexCore</h2>
                <p class="game-description">Select a game mode from the navigation above to start training.</p>
                
                <div id="ad-google-middle" class="ad-container ad-container-google-middle">
                    <div class="ad-label">Advertisement</div>
                    <div class="ad-placeholder-text"></div>
                </div>
                
                <h3 class="game-subtitle">Your High Scores</h3>
                <div id="high-scores-display" class="high-scores">
                    <p>Loading scores...</p>
                </div>
            </div>

            <div id="game-container" class="game-container">
                </div>
            
            <div id="static-content-container" class="static-content" hidden>
                </div>
            
        </main>
        
        <aside class="sidebar">
            <div class="sidebar-widget">
                <h3 class="widget-title">Live Stats</h3>
                <div id="live-stats" class="live-stats">
                    <div class="stat-item">
                        <span class="stat-label">Hits:</span>
                        <span id="stat-hits" class="stat-value">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Misses:</span>
                        <span id="stat-misses" class="stat-value">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Accuracy:</span>
                        <span id="stat-accuracy" class="stat-value">0%</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Time:</span>
                        <span id="stat-timer" class="stat-value">0.0s</span>
                    </div>
                </div>
            </div>
            
            <div id="ad-sidebar-skyscraper" class="ad-container ad-container-sidebar">
                 <div class="ad-label">Advertisement</div>
                 <div class="ad-placeholder-text"></div>
            </div>
        </aside>
    </div>

    <footer class="main-footer">
        <p>&copy; 2025 ReflexCore. All rights reserved.</p>
        <p>
            <a href="https://fortstar77.github.io/privacy" target="_blank">Privacy Policy</a> | 
            <a href="/terms.html">Terms of Use</a>
        </p>
    </footer>

    <dialog id="stats-modal" class="modal">
        <div class="modal-content">
            <button class="modal-close-btn" data-close-modal="stats-modal" aria-label="Close statistics modal">&times;</button>
            <h2 id="modal-title" class="modal-title">Game Over!</h2>
            <div id="modal-body" class="modal-body">
                <p>Average reaction time: <span id="final-avg-reaction">0</span> ms</p>
                <p>Hits: <span id="final-hits">0</span></p>
                <p>Misses: <span id="final-misses">0</span></p>
                <p>Accuracy: <span id="final-accuracy">0</span>%</p>
                <p>CPS: <span id="final-cps">0</span></p>
                <h3 id="final-new-highscore" class="new-highscore" hidden>New High Score!</h3>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" data-close-modal="stats-modal">Close</button>
            </div>
        </div>
    </dialog>
    
    <dialog id="ad-notification-modal" class="modal modal-ad">
        <div class="modal-content">
            <button class="modal-close-btn" data-close-modal="ad-notification-modal" aria-label="Close ad">&times;</button>
            <h2 class="modal-title ad-label">Advertisement</h2>
            <div id="ad-notification-content" class="modal-body">
                <div class="ad-placeholder-text"></div>
                <p class="ad-sub-text">The game will start shortly...</p>
            </div>
        </div>
    </dialog>

    <script>
        /*
        =======================================================================
         MAIN APPLICATION FILE: ReflexCore v1.0
         Total code length: > 2000 lines
         
         Table of Contents:
         1. Module 1: Initialization, App State, and DOM Selectors
         2. Module 2: Settings Management (Theme, Language, Game)
         3. Module 3: UI Management (Navigation, Modals)
         4. Module 4: Data Management (LocalStorage, Scores)
         5. Module 5: Game Mode - Aim Trainer
         6. Module 6: Game Mode - Tracking
         7. Module 7: Game Mode - Typing Test
         8. Module 8: Game Mode - Memory Game
         9. Module 9: Game Mode - Whac-a-Mole
         10. Module 10: App Initialization (Main Loop)
        =======================================================================
        */

        // Use "strict mode" for better code quality and error handling
        'use strict';

        /*
        =======================================================================
         1. Module 1: Initialization, App State, and DOM Selectors
        =======================================================================
        */

        // Object holding the global application state
        const AppState = {
            // Stores references to all key DOM elements
            // This avoids repeated document.querySelector calls
            DOM: {},
            
            // Stores user settings (loaded from localStorage)
            settings: {
                theme: 'light',
                language: 'en', // Zmieniono domy≈õlny na 'en'
                gameSettings: {
                    '--target-size': 50, // Default value
                    '--target-color': '#FF4136' // Default value
                }
            },
            
            // Stores stats and timers for the currently active game
            currentGame: {
                isActive: false,
                gameMode: null, // e.g., 'aimTrainer', 'typingTest'
                timerInterval: null,
                startTime: 0,
                endTime: 0,
                hits: 0,
                misses: 0,
                reactionTimes: [], // Array for storing reaction times
                lastReactionTime: 0,
                cpsCounter: {
                    clicks: 0,
                    timer: null,
                    isMeasuring: false
                },
                accuracy: 0 // Added for typing test
            },
            
            // Stores high scores (loaded from localStorage)
            highScores: {}
        };

        /**
         * Initializes DOM selectors.
         * Called once after the DOM tree has loaded.
         */
        function initializeDOMSelectors() {
            const D = AppState.DOM; // Shortcut
            
            // Main containers
            D.mainContent = document.getElementById('main-content');
            D.gameContainer = document.getElementById('game-container');
            D.staticContentContainer = document.getElementById('static-content-container');
            D.welcomeScreen = document.getElementById('welcome-screen');
            
            // Navigation
            D.mainNav = document.querySelector('.main-nav');
            D.navButtons = document.querySelectorAll('.nav-btn');
            
            // Settings Panel
            D.settingsPanel = document.getElementById('settings-panel');
            D.settingsToggleBtn = document.getElementById('settings-toggle-btn');
            D.themeToggle = document.getElementById('theme-toggle');
            D.languageSelect = document.getElementById('language-select');
            D.targetSizeSlider = document.getElementById('target-size-slider');
            D.targetSizeValue = document.getElementById('target-size-value');
            D.targetColorPicker = document.getElementById('target-color-picker');
            D.resetStatsBtn = document.getElementById('reset-stats-btn');
            
            // Live Stats (Sidebar)
            D.liveStats = {
                hits: document.getElementById('stat-hits'),
                misses: document.getElementById('stat-misses'),
                accuracy: document.getElementById('stat-accuracy'),
                timer: document.getElementById('stat-timer')
            };
            
            // Final Stats Modal
            D.statsModal = document.getElementById('stats-modal');
            D.statsModalTitle = document.getElementById('modal-title');
            D.statsModalBody = document.getElementById('modal-body');
            D.statsModalNewHighScore = document.getElementById('final-new-highscore');
            D.statsModalCloseBtns = document.querySelectorAll('[data-close-modal="stats-modal"]');
            
            // Ad (Notification) Modal
            D.adNotificationModal = document.getElementById('ad-notification-modal');
            D.adNotificationModalCloseBtns = document.querySelectorAll('[data-close-modal="ad-notification-modal"]');
            
            // High Scores Display
            D.highScoresDisplay = document.getElementById('high-scores-display');
            
            // Reference to :root for CSS variables
            D.root = document.documentElement;
        }


        /*
        =======================================================================
         2. Module 2: Settings Management (Theme, Language, Game)
        =======================================================================
        */

        /**
         * Initializes event listeners for the settings panel.
         */
        function initializeSettingsPanel() {
            const D = AppState.DOM;

            // Panel open/close toggle
            D.settingsToggleBtn.addEventListener('click', toggleSettingsPanel);
            
            // Theme Toggle
            D.themeToggle.addEventListener('change', handleThemeChange);
            
            // Language Toggle (currently a placeholder, requires i18n implementation)
            D.languageSelect.addEventListener('change', handleLanguageChange);
            
            // Target Size Slider
            D.targetSizeSlider.addEventListener('input', handleGameSettingChange);
            
            // Target Color Picker
            D.targetColorPicker.addEventListener('input', handleGameSettingChange);
            
            // Reset Stats
            D.resetStatsBtn.addEventListener('click', handleResetHighScores);
        }

        /**
         * Shows or hides the settings panel.
         */
        function toggleSettingsPanel() {
            const D = AppState.DOM;
            const isOpen = D.settingsPanel.classList.toggle('open');
            D.settingsPanel.hidden = !isOpen;
            
            // Adjust main content width for better RWD
            if (window.innerWidth < 1200) { // On mobile/tablet, layout doesn't change
                // On larger screens
                D.mainContent.classList.toggle('full-width', !isOpen);
            }
            
            // ARIA settings for accessibility
            D.settingsToggleBtn.setAttribute('aria-expanded', isOpen.toString());
            D.settingsPanel.setAttribute('aria-hidden', (!isOpen).toString());
        }

        /**
         * Handles theme change (Light/Dark).
         * @param {Event} e - The 'change' event from the toggle.
         */
        function handleThemeChange(e) {
            const newTheme = e.target.checked ? 'dark' : 'light';
            applyTheme(newTheme);
            saveSetting('theme', newTheme);
        }

        /**
         * Applies the selected theme by changing the attribute on the <html> tag.
         * @param {string} themeName - The theme name ('light' or 'dark').
         */
        function applyTheme(themeName) {
            AppState.DOM.root.setAttribute('data-theme', themeName);
            AppState.settings.theme = themeName;
            
            // Set the toggle's state according to the loaded theme
            if (AppState.DOM.themeToggle) {
                AppState.DOM.themeToggle.checked = (themeName === 'dark');
            }
        }

        /**
         * Handles language change.
         * @param {Event} e - The 'change' event from the selector.
         */
        function handleLanguageChange(e) {
            const newLang = e.target.value;
            applyLanguage(newLang);
            saveSetting('language', newLang);
            // NOTE: This will require a page reload or a full i18n library to translate existing text.
            // For this demo, it just sets the preference.
            alert("Language change requires a page reload to see all effects.");
        }

        /**
         * Applies the selected language (i18n logic to be expanded).
         * @param {string} langCode - Language code ('pl' or 'en').
         */
        function applyLanguage(langCode) {
            AppState.DOM.root.setAttribute('lang', langCode);
            AppState.settings.language = langCode;
            console.log(`Language changed to: ${langCode}. (Full i18n implementation needed)`);
            // This is where you would implement swapping all text on the page
            // e.g., based on a JSON object with translations.
        }

        /**
         * Handles game setting changes (sliders, colors).
         * Uses .setProperty to dynamically change CSS variables.
         * @param {Event} e - The 'input' event from the slider or color picker.
         */
        function handleGameSettingChange(e) {
            const D = AppState.DOM;
            const element = e.target;
            const cssVar = element.dataset.cssVar; // e.g., '--target-size'
            let value = element.value;

            if (!cssVar) return;

            // If it's a slider, add 'px' and update the label
            if (element.type === 'range') {
                const unit = 'px';
                value = `${value}${unit}`;
                
                // Update label (e.g., "Target Size: 50px")
                if (cssVar === '--target-size' && D.targetSizeValue) {
                    D.targetSizeValue.textContent = element.value;
                }
            }
            
            // Dynamically change the CSS variable
            D.root.style.setProperty(cssVar, value);
            
            // Save to the settings object
            AppState.settings.gameSettings[cssVar] = element.value;
            saveSetting('gameSettings', AppState.settings.gameSettings);
        }

        /**
         * Applies saved game settings (e.g., target size) on load.
         */
        function applySavedGameSettings() {
            const D = AppState.DOM;
            const settings = AppState.settings.gameSettings;
            
            for (const cssVar in settings) {
                const value = settings[cssVar];
                let valueWithUnit = value;
                
                // Update slider and label
                if (cssVar === '--target-size' && D.targetSizeSlider) {
                    D.targetSizeSlider.value = value;
                    D.targetSizeValue.textContent = value;
                    valueWithUnit = `${value}px`;
                }
                
                // Update color picker
                if (cssVar === '--target-color' && D.targetColorPicker) {
                    D.targetColorPicker.value = value;
                }
                
                // Apply the CSS variable
                D.root.style.setProperty(cssVar, valueWithUnit);
            }
        }


        /*
        =======================================================================
         3. Module 3: UI Management (Navigation, Modals)
        =======================================================================
        */

        /**
         * Initializes the main navigation (switching game modes).
         */
        function initializeNavigation() {
            const D = AppState.DOM;
            D.mainNav.addEventListener('click', (e) => {
                const target = e.target.closest('.nav-btn');
                if (!target) return;
                
                // Remove active class from all buttons
                D.navButtons.forEach(btn => btn.classList.remove('active'));
                // Add active class to the clicked one
                target.classList.add('active');
                
                const gameMode = target.dataset.game;
                const section = target.dataset.section;
                
                if (gameMode) {
                    // Switch to game mode
                    showGameScreen(gameMode);
                } else if (section) {
                    // Switch to static section (Blog/FAQ)
                    showStaticScreen(section);
                }
            });
        }

        /**
         * Shows the appropriate game screen and hides others.
         * @param {string} gameMode - ID of the game mode (e.g., 'aimTrainer').
         */
        function showGameScreen(gameMode) {
            const D = AppState.DOM;
            
            // Stop the previous game if one was active
            stopCurrentGame();
            
            // Hide welcome screen and static container
            D.welcomeScreen.classList.remove('active');
            D.staticContentContainer.hidden = true;
            
            // Clear the game container
            D.gameContainer.innerHTML = '';
            D.gameContainer.hidden = false;
            
            // Reset live stats
            resetLiveStats();
            
            let title, description, buttonText;
            
            // Generate HTML for the selected game's start screen
            switch (gameMode) {
                case 'aimTrainer':
                    title = 'Aim Trainer';
                    description = 'Click as many targets as you can in 30 seconds. Speed and precision count.';
                    buttonText = 'Start (Aim Trainer)';
                    break;
                case 'tracking':
                    title = 'Tracking Practice';
                    description = 'Keep your cursor on the moving target for as long as you can. The game lasts 30 seconds.';
                    buttonText = 'Start (Tracking)';
                    break;
                case 'typingTest':
                    title = 'Typing Speed Test (WPM)';
                    description = 'Measure your typing speed (Words Per Minute). Retype the given text as quickly and accurately as you can. The test lasts 60 seconds.';
                    buttonText = 'Start Typing Test';
                    break;
                case 'memoryGame':
                    title = 'Memory Game';
                    description = 'Find all matching pairs of cards. Try to do it in the fewest moves.';
                    buttonText = 'Start (Memory)';
                    break;
                case 'whacAMole':
                    title = 'Whac-a-Mole';
                    description = 'Hit the appearing moles! The game lasts 30 seconds. Watch out for misses!';
                    buttonText = 'Start (Whac-a-Mole)';
                    break;
                default:
                    return;
            }
            
            // Special handling for games that don't have a "Start" screen (like memory or typing)
            if (gameMode === 'typingTest') {
                startTypingTest(); // This game builds its own UI immediately
                return;
            }
            if (gameMode === 'memoryGame') {
                startMemoryGame(); // This game also starts immediately
                return;
            }

            // Create the start screen for the selected game
            const gameStartScreen = `
                <div class="game-start-screen" id="start-screen-${gameMode}">
                    <h2 class="game-title">${title}</h2>
                    <p class="game-description">${description}</p>
                    <button class="btn btn-primary" id="start-game-btn" data-start-game="${gameMode}">
                        ${buttonText}
                    </button>
                </div>
            `;
            D.gameContainer.innerHTML = gameStartScreen;
            
            // Find the newly created start button and add a listener
            const startGameBtn = document.getElementById('start-game-btn');
            startGameBtn.addEventListener('click', handleGameStartClick);
        }

        /**
         * Shows the static content screen (Blog/FAQ).
         * @param {string} sectionName - Name of the section ('blog' or 'faq').
         */
        function showStaticScreen(sectionName) {
            const D = AppState.DOM;
            
            // Stop any active game
            stopCurrentGame();
            
            // Hide welcome screen and game container
            D.welcomeScreen.classList.remove('active');
            D.gameContainer.hidden = true;
            
            // Show static container
            D.staticContentContainer.hidden = false;
            
            // Load the appropriate content (placeholder)
            if (sectionName === 'blog') {
                D.staticContentContainer.innerHTML = `<h2>Blog / Guides</h2><p>Blog content will appear here...</p>`;
            } else if (sectionName === 'faq') {
                D.staticContentContainer.innerHTML = `<h2>FAQ - Frequently Asked Questions</h2><p>FAQ content will appear here...</p>`;
            }
        }

        /**
         * Initializes handling for all modal windows.
         */
        function initializeModals() {
            const D = AppState.DOM;
            
            // Closing the Stats Modal
            D.statsModalCloseBtns.forEach(btn => {
                btn.addEventListener('click', () => closeModal('stats-modal'));
            });
            // Closing the Ad Modal
            D.adNotificationModalCloseBtns.forEach(btn => {
                btn.addEventListener('click', () => closeModal('ad-notification-modal'));
            });
            
            // Close modal with Escape key (for accessibility)
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (D.statsModal.open) {
                        closeModal('stats-modal');
                    }
                    if (D.adNotificationModal.open) {
                        closeModal('ad-notification-modal');
                    }
                }
            });
            
            // Close modal by clicking on the backdrop
            D.statsModal.addEventListener('click', (e) => {
                if (e.target.id === 'stats-modal') closeModal('stats-modal');
            });
            D.adNotificationModal.addEventListener('click', (e) => {
                if (e.target.id === 'ad-notification-modal') closeModal('ad-notification-modal');
            });
        }

        /**
         * Opens a specific modal (dialog).
         * Uses .showModal() for native modal handling.
         * Manages focus for accessibility.
         * @param {string} modalId - ID of the modal to open.
         */
        function openModal(modalId) {
            const modal = document.getElementById(modalId);
            if (!modal) return;
            
            modal.showModal();
            
            // Move focus to the modal (or first focusable element) for WAI-ARIA
            const firstFocusableElement = modal.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
            if (firstFocusableElement) {
                firstFocusableElement.focus();
            }
        }

        /**
         * Closes a specific modal.
         * Uses .close().
         * @param {string} modalId - ID of the modal to close.
         */
        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.close();
            }
        }

        /*
        =======================================================================
         4. Module 4: Data Management (LocalStorage, Scores)
        =======================================================================
        */

        // Primary key for localStorage
        const LOCAL_STORAGE_KEY_SETTINGS = 'reflexCoreSettings';
        const LOCAL_STORAGE_KEY_SCORES = 'reflexCoreHighScores';

        /**
         * Saves a single setting or an entire group to localStorage.
         * @param {string} key - The main key (e.g., 'theme' or 'gameSettings').
         * @param {*} value - The value to save.
         */
        function saveSetting(key, value) {
            AppState.settings[key] = value;
            // Save the entire settings object as JSON
            localStorage.setItem(LOCAL_STORAGE_KEY_SETTINGS, JSON.stringify(AppState.settings));
        }

        /**
         * Loads settings from localStorage during initialization.
         */
        function loadSettings() {
            // Use "try...catch" in case localStorage is disabled or data is corrupted
            try {
                const savedSettings = localStorage.getItem(LOCAL_STORAGE_KEY_SETTINGS);
                
                if (savedSettings) {
                    const parsedSettings = JSON.parse(savedSettings);
                    // Merge saved settings with defaults to avoid errors
                    // Use a deep merge for gameSettings
                    AppState.settings = {
                        ...AppState.settings,
                        ...parsedSettings,
                        gameSettings: {
                            ...AppState.settings.gameSettings,
                            ...(parsedSettings.gameSettings || {})
                        }
                    };
                }
            } catch (error) {
                console.error("Failed to load settings from localStorage:", error);
            }
            
            // Apply loaded (or default) settings
            applyTheme(AppState.settings.theme);
            applyLanguage(AppState.settings.language);
            applySavedGameSettings();
        }

        /**
         * Saves high scores to localStorage.
         * @param {string} gameMode - ID of the game mode.
         * @param {object} scoreData - Object with the score (e.g., { score: 100, reaction: 150 }).
         */
        function saveHighScore(gameMode, scoreData) {
            // Save the entire scores object
            AppState.highScores[gameMode] = scoreData;
            try {
                localStorage.setItem(LOCAL_STORAGE_KEY_SCORES, JSON.stringify(AppState.highScores));
            } catch (error) {
                console.error("Failed to save high scores to localStorage:", error);
            }
            
            // Refresh the high scores display on the main screen
            updateHighScoresDisplay();
        }

        /**
         * Loads high scores from localStorage.
         */
        function loadHighScores() {
            try {
                const savedScores = localStorage.getItem(LOCAL_STORAGE_KEY_SCORES);
                if (savedScores) {
                    AppState.highScores = JSON.parse(savedScores);
                }
            } catch (error) {
                console.error("Failed to load high scores from localStorage:", error);
            }
            
            // Refresh display
            updateHighScoresDisplay();
        }

        /**
         * Updates the "High Scores" section on the welcome screen.
         */
        function updateHighScoresDisplay() {
            const D = AppState.DOM;
            if (!D.highScoresDisplay) return;
            
            const scores = AppState.highScores;
            let html = '';
            
            if (Object.keys(scores).length === 0) {
                html = '<p>No saved scores. Play a game to set a record!</p>';
            } else {
                html = '<ul>';
                if (scores.aimTrainer) {
                    html += `<li><strong>Aim Trainer:</strong> ${scores.aimTrainer.score} pts (Avg: ${scores.aimTrainer.reaction}ms)</li>`;
                }
                if (scores.tracking) {
                    html += `<li><strong>Tracking:</strong> ${scores.tracking.score.toFixed(2)}% accuracy</li>`;
                }
                if (scores.typingTest) {
                    html += `<li><strong>Typing Test:</strong> ${scores.typingTest.wpm} WPM (Accuracy: ${scores.typingTest.accuracy}%)</li>`;
                }
                if (scores.memoryGame) {
                    html += `<li><strong>Memory Game:</strong> ${scores.memoryGame.moves} moves</li>`;
                }
                if (scores.whacAMole) {
                    html += `<li><strong>Whac-a-Mole:</strong> ${scores.whacAMole.score} pts</li>`;
                }
                html += '</ul>';
            }
            
            D.highScoresDisplay.innerHTML = html;
        }

        /**
         * Handles resetting high scores.
         */
        function handleResetHighScores() {
            if (confirm('Are you sure you want to reset all your high scores? This action cannot be undone.')) {
                AppState.highScores = {};
                try {
                    localStorage.removeItem(LOCAL_STORAGE_KEY_SCORES);
                } catch (error) {
                    console.error("Error while resetting scores:", error);
                }
                updateHighScoresDisplay();
                console.log("High scores have been reset.");
            }
        }


        /*
        =======================================================================
         5. Module 5: Game Mode - Aim Trainer
        =======================================================================
        */

        // Settings specific to Aim Trainer
        const AimTrainerSettings = {
            GAME_DURATION: 30000 // 30 seconds
        };

        /**
         * Starts the Aim Trainer game.
         */
        function startAimTrainer() {
            const D = AppState.DOM;
            const C = AppState.currentGame;
            
            C.gameMode = 'aimTrainer';
            
            // Prepare the game container
            D.gameContainer.innerHTML = '<div class="game-area" id="aim-trainer-area"></div>';
            D.gameArea = document.getElementById('aim-trainer-area');
            
            // Reset stats
            C.isActive = true;
            C.hits = 0;
            C.misses = 0;
            C.reactionTimes = [];
            C.lastReactionTime = Date.now();
            resetLiveStats();
            
            // Handle clicks (hits/misses)
            D.gameArea.addEventListener('mousedown', handleAimTrainerClick);
            
            // Start CPS measurement
            startCPSMeasure();
            
            // Start game timer
            C.startTime = Date.now();
            C.timerInterval = setInterval(updateGameTimer, 100);
            
            // Set the timer to end the game
            setTimeout(stopAimTrainer, AimTrainerSettings.GAME_DURATION);
            
            // Create the first target
            spawnTarget();
        }

        /**
         * Stops the Aim Trainer game.
         */
        function stopAimTrainer() {
            const C = AppState.currentGame;
            if (!C.isActive || C.gameMode !== 'aimTrainer') return;
            
            C.isActive = false;
            C.endTime = Date.now();
            clearInterval(C.timerInterval);
            stopCPSMeasure();
            
            // Remove listener to avoid clicks after finishing
            if (AppState.DOM.gameArea) {
                AppState.DOM.gameArea.removeEventListener('mousedown', handleAimTrainerClick);
            }
            
            // Remove the last target
            const target = AppState.DOM.gameArea.querySelector('.target');
            if (target) {
                target.remove();
            }
            
            // Calculate final stats
            showFinalStats('aimTrainer');
        }

        /**
         * Creates and displays a new target in a random location.
         */
        function spawnTarget() {
            const C = AppState.currentGame;
            if (!C.isActive) return;
            
            const D = AppState.DOM;
            const gameArea = D.gameArea;
            if (!gameArea) return; // Safety check if game ended in the meantime

            // Remove the previous target, if it exists
            const oldTarget = gameArea.querySelector('.target');
            if (oldTarget) {
                oldTarget.remove();
            }
            
            const target = document.createElement('div');
            target.className = 'target';
            
            // Get the dynamic size from the CSS variable (set in the panel)
            const targetSize = parseInt(D.root.style.getPropertyValue('--target-size') || AppState.settings.gameSettings['--target-size']);
            
            // Calculate random position
            const maxWidth = gameArea.clientWidth - targetSize;
            const maxHeight = gameArea.clientHeight - targetSize;
            
            const x = Math.floor(Math.random() * maxWidth);
            const y = Math.floor(Math.random() * maxHeight);
            
            target.style.left = `${x}px`;
            target.style.top = `${y}px`;
            
            // Listener for hits
            target.addEventListener('mousedown', handleTargetHit);
            
            gameArea.appendChild(target);
            
            // Save the time the target appeared to calculate reaction time
            C.lastReactionTime = Date.now();
        }

        /**
         * Handles a click in the game area (hit or miss).
         * @param {Event} e - The 'mousedown' event.
         */
        function handleAimTrainerClick(e) {
            // Check if the click was directly on the game area (a miss)
            if (e.target.id === 'aim-trainer-area') {
                handleTargetMiss();
            }
        }

        /**
         * Handles hitting a target.
         * @param {Event} e - The 'mousedown' event on the target.
         */
        function handleTargetHit(e) {
            const C = AppState.currentGame;
            if (!C.isActive) return;
            
            // Prevent event propagation to gameArea (to not count a miss)
            e.stopPropagation();
            
            // Calculate reaction time
            const reactionTime = Date.now() - C.lastReactionTime;
            C.reactionTimes.push(reactionTime);
            
            C.hits++;
            updateLiveStats();
            
            // Immediately create a new target
            spawnTarget();
        }

        /**
         * Handles a miss (clicking next to the target).
         */
        function handleTargetMiss() {
            const C = AppState.currentGame;
            if (!C.isActive) return;
            
            C.misses++;
            updateLiveStats();
        }

        /**
         * Calculates the average reaction time from the array.
         * @returns {number} - Average reaction time in ms.
         */
        function calculateAverageReactionTime() {
            const C = AppState.currentGame;
            if (C.reactionTimes.length === 0) return 0;
            
            const sum = C.reactionTimes.reduce((a, b) => a + b, 0);
            return Math.round(sum / C.reactionTimes.length);
        }

        /**
         * Starts measuring CPS (Clicks Per Second).
         */
        function startCPSMeasure() {
            const C = AppState.currentGame;
            const CPS = C.cpsCounter;
            
            if (CPS.isMeasuring) return;
            
            CPS.isMeasuring = true;
            CPS.clicks = 0;
            
            // Listener to count all clicks
            if(AppState.DOM.gameArea) {
                AppState.DOM.gameArea.addEventListener('mousedown', countClickForCPS);
            }
            
            // Timer to reset the CPS counter every second (for live stats)
            CPS.timer = setInterval(() => {
                // Update live CPS (if we have such a stat in the sidebar)
                // console.log(`CPS: ${CPS.clicks}`);
                CPS.clicks = 0; // Reset every second
            }, 1000);
        }

        /**
         * Counts a click for CPS measurement.
         */
        function countClickForCPS() {
            if (AppState.currentGame.cpsCounter.isMeasuring) {
                AppState.currentGame.cpsCounter.clicks++;
            }
        }

        /**
         * Stops CPS measurement.
         */
        function stopCPSMeasure() {
            const C = AppState.currentGame;
            const CPS = C.cpsCounter;
            
            if (!CPS.isMeasuring) return;
            
            CPS.isMeasuring = false;
            clearInterval(CPS.timer);
            if (AppState.DOM.gameArea) {
                AppState.DOM.gameArea.removeEventListener('mousedown', countClickForCPS);
            }
        }

        /**
         * Calculates the final, average CPS for the entire session.
         * @returns {number} - Average CPS.
         */
        function calculateFinalCPS() {
            const C = AppState.currentGame;
            const totalClicks = C.hits + C.misses;
            const durationInSeconds = (C.endTime - C.startTime) / 1000;
            
            if (durationInSeconds === 0) return 0;
            
            return (totalClicks / durationInSeconds).toFixed(2);
        }


        /*
        =======================================================================
         6. Module 6: Game Mode - Tracking
        =======================================================================
        */

        // Settings specific to Tracking
        const TrackingSettings = {
            GAME_DURATION: 30000, // 30 seconds
            TARGET_SPEED: 3,      // pixels per frame
            UPDATE_RATE: 1000 / 60 // 60 FPS
        };

        // State specific to Tracking
        const TrackingState = {
            targetEl: null,
            targetPos: { x: 50, y: 50 },
            targetVel: { x: TrackingSettings.TARGET_SPEED, y: TrackingSettings.TARGET_SPEED },
            gameLoop: null,
            isMouseOverTarget: false,
            timeOnTarget: 0,
            totalTime: 0
        };

        /**
         * Starts the Tracking game.
         */
        function startTrackingGame() {
            const D = AppState.DOM;
            const C = AppState.currentGame;
            
            C.gameMode = 'tracking';
            
            // Prepare game container
            D.gameContainer.innerHTML = '<div class="game-area" id="tracking-area"></div>';
            D.gameArea = document.getElementById('tracking-area');
            
            // Create the target
            const target = document.createElement('div');
            target.className = 'target';
            D.gameArea.appendChild(target);
            TrackingState.targetEl = target;
            
            // Reset stats
            C.isActive = true;
            C.hits = 0; // In this game, "hits" is time on target
            C.misses = 0; // "misses" is time off target
            TrackingState.timeOnTarget = 0;
            TrackingState.totalTime = 0;
            TrackingState.isMouseOverTarget = false;
            
            // Reset target position
            TrackingState.targetPos = { x: 50, y: 50 };
            TrackingState.targetVel = { x: TrackingSettings.TARGET_SPEED, y: TrackingSettings.TARGET_SPEED };
            
            resetLiveStats();
            
            // Listeners for tracking the mouse on the target
            TrackingState.targetEl.addEventListener('mouseenter', () => {
                TrackingState.isMouseOverTarget = true;
            });
            TrackingState.targetEl.addEventListener('mouseleave', () => {
                TrackingState.isMouseOverTarget = false;
            });
            
            // Start game timer
            C.startTime = Date.now();
            C.timerInterval = setInterval(updateGameTimer, 100);
            
            // Start the main game loop (target animation)
            TrackingState.gameLoop = setInterval(updateTrackingGame, TrackingSettings.UPDATE_RATE);
            
            // Set timer to end the game
            setTimeout(stopTrackingGame, TrackingSettings.GAME_DURATION);
        }

        /**
         * Stops the Tracking game.
         */
        function stopTrackingGame() {
            const C = AppState.currentGame;
            if (!C.isActive || C.gameMode !== 'tracking') return;
            
            C.isActive = false;
            C.endTime = Date.now();
            clearInterval(C.timerInterval);
            clearInterval(TrackingState.gameLoop);
            
            // Remove the target
            if (TrackingState.targetEl) {
                TrackingState.targetEl.remove();
                TrackingState.targetEl = null;
            }
            
            // Calculate final stats
            showFinalStats('tracking');
        }

        /**
         * Main Tracking game loop (updated 60 times per second).
         */
        function updateTrackingGame() {
            const C = AppState.currentGame;
            if (!C.isActive) return;
            
            const D = AppState.DOM;
            const S = TrackingState;
            const gameArea = D.gameArea;
            const target = S.targetEl;
            
            if (!gameArea || !target) return;
            
            const targetSize = parseInt(D.root.style.getPropertyValue('--target-size') || AppState.settings.gameSettings['--target-size']);
            const areaWidth = gameArea.clientWidth;
            const areaHeight = gameArea.clientHeight;

            // Update target position
            S.targetPos.x += S.targetVel.x;
            S.targetPos.y += S.targetVel.y;

            // Bounce off walls
            if (S.targetPos.x <= 0 || S.targetPos.x >= areaWidth - targetSize) {
                S.targetVel.x *= -1; // Change X direction
            }
            if (S.targetPos.y <= 0 || S.targetPos.y >= areaHeight - targetSize) {
                S.targetVel.y *= -1; // Change Y direction
            }
            
            // Ensure the target stays within bounds
            S.targetPos.x = Math.max(0, Math.min(S.targetPos.x, areaWidth - targetSize));
            S.targetPos.y = Math.max(0, Math.min(S.targetPos.y, areaHeight - targetSize));

            // Apply new position
            target.style.left = `${S.targetPos.x}px`;
            target.style.top = `${S.targetPos.y}px`;
            
            // Count time on target
            S.totalTime += TrackingSettings.UPDATE_RATE;
            if (S.isMouseOverTarget) {
                S.timeOnTarget += TrackingSettings.UPDATE_RATE;
                C.hits = S.timeOnTarget; // Use 'hits' to store time on target
            } else {
                C.misses = S.totalTime - S.timeOnTarget; // 'misses' is time off target
            }
            
            // Update live stats
            updateLiveStats();
        }


        /*
        =======================================================================
         7. Module 7: Game Mode - Typing Test
        =======================================================================
        */

        // Settings specific to Typing Test
        const TypingTestSettings = {
            GAME_DURATION: 60000, // 60 seconds
            // Sample texts (can be loaded from an API)
            TEXT_SAMPLES: [
                "The quick brown fox jumps over the lazy dog. This sentence contains all letters of the alphabet and is often used to test fonts and keyboards.",
                "Programming is the art and science of creating instructions for a computer. It requires logic, creativity, and patience. Anyone can learn it.",
                "ReflexCore helps improve reaction time. Regular aim training is crucial for gamers. Practice daily to see the best results.",
                "The Baltic Sea is a relatively young and shallow inland sea. Its salinity is much lower than in most other seas."
            ]
        };

        // State specific to Typing Test
        const TypingState = {
            textToType: "",
            currentIndex: 0,
            errors: 0,
            totalTyped: 0,
            startTime: 0,
            inputElement: null,
            textDisplayElement: null
        };

        /**
         * Starts the Typing Test game.
         */
        function startTypingTest() {
            const D = AppState.DOM;
            const C = AppState.currentGame;
            
            C.gameMode = 'typingTest';
            
            // Generate game UI
            D.gameContainer.innerHTML = `
                <div class="typing-test-container">
                    <div class="typing-stats">
                        <div class="typing-stat-item">
                            <div class="typing-stat-label">Time</div>
                            <div class="typing-stat-value" id="typing-timer">60</div>
                        </div>
                        <div class="typing-stat-item">
                            <div class="typing-stat-label">WPM</div>
                            <div class="typing-stat-value" id="typing-wpm">0</div>
                        </div>
                        <div class="typing-stat-item">
                            <div class="typing-stat-label">Errors</div>
                            <div class="typing-stat-value" id="typing-errors">0</div>
                        </div>
                        <div class="typing-stat-item">
                            <div class="typing-stat-label">Accuracy</div>
                            <div class="typing-stat-value" id="typing-accuracy">100%</div>
                        </div>
                    </div>
                    <div class="typing-text-display" id="typing-text-display"></div>
                    <input type="text" class="typing-input-area" id="typing-input-area" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" autofocus>
                    <button class="btn btn-primary typing-restart-btn" id="typing-restart-btn" hidden>Try Again</button>
                </div>
            `;
            
            // Save references to new DOM elements
            TypingState.inputElement = document.getElementById('typing-input-area');
            TypingState.textDisplayElement = document.getElementById('typing-text-display');
            const timerDisplay = document.getElementById('typing-timer');
            const restartBtn = document.getElementById('typing-restart-btn');
            
            // Reset stats
            C.isActive = true;
            C.hits = 0; // We'll use hits for WPM
            C.misses = 0; // We'll use misses for errors
            TypingState.currentIndex = 0;
            TypingState.errors = 0;
            TypingState.totalTyped = 0;
            TypingState.startTime = 0; // Will be set on first keypress
            
            // Load and display text
            loadTypingText();
            
            // Add listeners
            TypingState.inputElement.addEventListener('input', handleTypingInput);
            TypingState.inputElement.addEventListener('keydown', handleTypingBackspace); // For backspace handling
            restartBtn.addEventListener('click', () => showGameScreen('typingTest')); // Restart
            
            // Set focus on the input field
            TypingState.inputElement.focus();
            
            // Start timer (but differently than in Aim Trainer)
            let timeLeft = TypingTestSettings.GAME_DURATION / 1000;
            timerDisplay.textContent = timeLeft;
            
            C.timerInterval = setInterval(() => {
                // Timer only starts after typing begins
                if (C.isActive && TypingState.startTime > 0) {
                    timeLeft--;
                    timerDisplay.textContent = timeLeft;
                    
                    // Update WPM live
                    updateTypingStats(false);
                    
                    if (timeLeft <= 0) {
                        stopTypingTest();
                    }
                }
            }, 1000);
        }

        /**
         * Stops the Typing Test game.
         */
        function stopTypingTest() {
            const C = AppState.currentGame;
            if (!C.isActive || C.gameMode !== 'typingTest') return;
            
            C.isActive = false;
            C.endTime = Date.now();
            clearInterval(C.timerInterval);
            
            // Disable the input field
            TypingState.inputElement.disabled = true;
            
            // Show the restart button
            document.getElementById('typing-restart-btn').hidden = false;
            
            // Calculate and show final stats
            updateTypingStats(true); // Final calculation
            showFinalStats('typingTest');
        }

        /**
         * Loads new text to type and renders it in the container.
         */
        function loadTypingText() {
            const S = TypingTestSettings;
            const T = TypingState;
            
            // Select a random text
            T.textToType = S.TEXT_SAMPLES[Math.floor(Math.random() * S.TEXT_SAMPLES.length)];
            
            // Transform the text into an array of spans (letters)
            const characters = T.textToType.split('').map(char => {
                return `<span class="char">${char}</span>`;
            }).join('');
            
            T.textDisplayElement.innerHTML = characters;
            
            // Highlight the first character
            T.textDisplayElement.querySelector('.char').classList.add('current');
        }

        /**
         * Handles text input from the user.
         * @param {Event} e - The 'input' event.
         */
        function handleTypingInput(e) {
            const C = AppState.currentGame;
            const T = TypingState;
            
            if (!C.isActive) return;
            
            // Start the timer on the first keypress
            if (T.startTime === 0) {
                T.startTime = Date.now();
            }
            
            const allChars = T.textDisplayElement.querySelectorAll('.char');
            const typedChar = e.data; // The last character typed

            // Ignore if it was a backspace (handled in handleTypingBackspace)
            if (typedChar === null) return; 

            // Ignore if we've reached the end
            if (T.currentIndex >= T.textToType.length) return;

            const charToType = T.textToType[T.currentIndex];
            const currentDisplayChar = allChars[T.currentIndex];
            
            T.totalTyped++;
            
            if (typedChar === charToType) {
                // Correct character
                currentDisplayChar.classList.add('correct');
                C.hits++; // Use 'hits' to count correct chars (for WPM)
            } else {
                // Incorrect character
                currentDisplayChar.classList.add('incorrect');
                T.errors++;
                C.misses = T.errors; // 'misses' for errors
            }
            
            currentDisplayChar.classList.remove('current');
            T.currentIndex++;
            
            // Check if the game is over (entire text typed)
            if (T.currentIndex === T.textToType.length) {
                stopTypingTest();
                return;
            }
            
            // Highlight the next character
            allChars[T.currentIndex].classList.add('current');
            
            // Update live stats (but not WPM, the timer does that)
            updateTypingStats(false);
        }

        /**
         * Handles backspace in the typing test
         */
        function handleTypingBackspace(e) {
            const T = TypingState;
            if (e.key !== 'Backspace' || T.currentIndex === 0 || !AppState.currentGame.isActive) {
                return;
            }

            // Prevent default action (deleting from input)
            e.preventDefault();

            const allChars = T.textDisplayElement.querySelectorAll('.char');
            
            // Remove "current" from the current character
            allChars[T.currentIndex].classList.remove('current');

            // Move the index
            T.currentIndex--;

            // The character we are returning to
            const charToCorrect = allChars[T.currentIndex];
            
            // Check if it was incorrect
            if (charToCorrect.classList.contains('incorrect')) {
                T.errors--;
                AppState.currentGame.misses = T.errors;
            }
            if (charToCorrect.classList.contains('correct')) {
                AppState.currentGame.hits--;
            }

            // Clear its state and set it as "current"
            charToCorrect.classList.remove('correct', 'incorrect');
            charToCorrect.classList.add('current');

            // Update the input field
            T.inputElement.value = T.inputElement.value.slice(0, -1);
            
            T.totalTyped--; // Also reduce the total typed
            updateTypingStats(false);
        }


        /**
         * Updates WPM, Errors, and Accuracy stats live or at the end of the game.
         * @param {boolean} isFinal - Is this the final calculation?
         */
        function updateTypingStats(isFinal) {
            const C = AppState.currentGame;
            const T = TypingState;
            
            const errorsDisplay = document.getElementById('typing-errors');
            const accuracyDisplay = document.getElementById('typing-accuracy');
            const wpmDisplay = document.getElementById('typing-wpm');

            if (!errorsDisplay) return; // Safety check in case the game was switched

            // Update errors
            errorsDisplay.textContent = T.errors;
            
            // Calculate accuracy
            let accuracy = 100;
            if (T.totalTyped > 0) {
                accuracy = Math.round(((T.totalTyped - T.errors) / T.totalTyped) * 100);
            }
            accuracyDisplay.textContent = `${accuracy}%`;
            C.accuracy = accuracy; // Save to global state
            
            // Calculate WPM (Words Per Minute)
            let timeElapsedInMinutes = (Date.now() - T.startTime) / 60000;
            if (isFinal) {
                // Use the exact time if the game ended
                const duration = (C.endTime > 0) ? (C.endTime - T.startTime) : TypingTestSettings.GAME_DURATION;
                timeElapsedInMinutes = duration / 60000;
            }
            
            if (timeElapsedInMinutes === 0 || T.startTime === 0) {
                wpmDisplay.textContent = 0;
                return;
            }
            
            // Standard formula: (number of correct words) / minutes
            // Word = average 5 characters (including spaces)
            // We use C.hits (correct chars) / 5
            const netWPM = Math.round( (C.hits / 5) / timeElapsedInMinutes );
            
            const finalWPM = Math.max(0, netWPM); // Don't show negative WPM
            
            wpmDisplay.textContent = finalWPM;
            
            // Save for final stats
            C.hits = finalWPM; // 'hits' as WPM
            C.misses = T.errors;
        }


        /*
        =======================================================================
         8. Module 8: Game Mode - Memory Game
        =======================================================================
        */

        // Settings specific to Memory Game
        const MemoryGameSettings = {
            CARD_EMOJIS: ['üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº'], // 8 pairs = 16 cards
            FLIP_DELAY: 1000 // 1 second to memorize
        };

        // State specific to Memory Game
        const MemoryState = {
            cards: [], // Array of card DOM elements
            flippedCards: [], // Max 2 cards
            matchedPairs: 0,
            totalMoves: 0,
            lockBoard: false // Lock board during animation
        };

        /**
         * Starts the Memory game.
         */
        function startMemoryGame() {
            const D = AppState.DOM;
            const C = AppState.currentGame;
            
            C.gameMode = 'memoryGame';
            
            // Prepare game container
            D.gameContainer.innerHTML = `
                <div class="game-start-screen" id="start-screen-memoryGame">
                     <h2 class="game-title">Memory Game</h2>
                     <p class="game-description" style="margin-bottom: 1rem;">
                         Moves: <span id="memory-moves" style="font-size: 1.2rem; font-weight: bold; color: var(--accent-color);">0</span>
                     </p>
                     <div class="memory-game-grid" id="memory-grid"></div>
                     <button class="btn btn-primary" id="memory-restart-btn" style="margin-top: 1.5rem;">Restart</button>
                </div>
            `;
            
            // Save references
            const grid = document.getElementById('memory-grid');
            const movesDisplay = document.getElementById('memory-moves');
            const restartBtn = document.getElementById('memory-restart-btn');
            
            // Reset state
            C.isActive = true;
            MemoryState.flippedCards = [];
            MemoryState.matchedPairs = 0;
            MemoryState.totalMoves = 0;
            MemoryState.lockBoard = false;
            C.hits = 0; // 'hits' will be moves
            movesDisplay.textContent = '0';
            
            // Generate and shuffle cards
            const cardSet = [...MemoryGameSettings.CARD_EMOJIS, ...MemoryGameSettings.CARD_EMOJIS];
            shuffleArray(cardSet);
            
            // Create cards in the DOM
            grid.innerHTML = ''; // Clear in case of restart
            MemoryState.cards = cardSet.map(emoji => createMemoryCard(emoji));
            MemoryState.cards.forEach(card => grid.appendChild(card));
            
            // Add listener to restart button
            restartBtn.addEventListener('click', () => showGameScreen('memoryGame'));
        }

        /**
         * Creates a single card for the Memory game.
         * @param {string} emoji - The emoji to be on the card.
         * @returns {HTMLElement} - The card's DOM element.
         */
        function createMemoryCard(emoji) {
            const card = document.createElement('div');
            card.className = 'memory-card';
            card.dataset.emoji = emoji; // Save the emoji in a data attribute
            
            card.innerHTML = `
                <div class="front-face">${emoji}</div>
                <div class="back-face">?</div>
            `;
            
            // Add listener for flipping
            card.addEventListener('click', () => handleMemoryCardFlip(card));
            return card;
        }

        /**
         * Handles clicking (flipping) a card.
         * @param {HTMLElement} card - The clicked card.
         */
        function handleMemoryCardFlip(card) {
            const M = MemoryState;
            const C = AppState.currentGame;
            
            // Do nothing if the board is locked, the card is already flipped, or we already have 2 cards
            if (M.lockBoard || card.classList.contains('flip') || M.flippedCards.length === 2 || card === M.flippedCards[0]) {
                return;
            }
            
            card.classList.add('flip');
            M.flippedCards.push(card);
            
            // If it's the first card, just wait
            if (M.flippedCards.length === 1) {
                return;
            }
            
            // If it's the second card, count the move and check for a match
            M.totalMoves++;
            C.hits = M.totalMoves;
            document.getElementById('memory-moves').textContent = M.totalMoves;
            
            // Lock the board while checking
            M.lockBoard = true;
            
            checkForMemoryMatch();
        }

        /**
         * Checks if the two flipped cards match.
         */
        function checkForMemoryMatch() {
            const M = MemoryState;
            const [cardOne, cardTwo] = M.flippedCards;
            
            const isMatch = cardOne.dataset.emoji === cardTwo.dataset.emoji;
            
            if (isMatch) {
                // Match
                disableMatchedCards();
            } else {
                // No match
                unflipMismatchedCards();
            }
        }

        /**
         * Disables matched cards (they stay flipped).
         */
        function disableMatchedCards() {
            const M = MemoryState;
            M.flippedCards[0].removeEventListener('click', handleMemoryCardFlip);
            M.flippedCards[1].removeEventListener('click', handleMemoryCardFlip);
            
            M.matchedPairs++;
            resetMemoryBoard();
            
            // Check for win condition
            if (M.matchedPairs === MemoryGameSettings.CARD_EMOJIS.length) {
                setTimeout(stopMemoryGame, 500); // Short delay for animation
            }
        }

        /**
         * Flips mismatched cards back over after a short delay.
         */
        function unflipMismatchedCards() {
            const M = MemoryState;
            setTimeout(() => {
                M.flippedCards[0].classList.remove('flip');
                M.flippedCards[1].classList.remove('flip');
                resetMemoryBoard();
            }, MemoryGameSettings.FLIP_DELAY);
        }

        /**
         * Resets the board state after a move (clears the flipped cards array).
         */
        function resetMemoryBoard() {
            MemoryState.flippedCards = [];
            MemoryState.lockBoard = false;
        }

        /**
         * Ends the Memory game.
         */
        function stopMemoryGame() {
            const C = AppState.currentGame;
            if (!C.isActive || C.gameMode !== 'memoryGame') return;
            
            C.isActive = false;
            C.endTime = Date.now();
            
            console.log(`Memory Game finished in ${MemoryState.totalMoves} moves.`);
            
            // Show final stats
            showFinalStats('memoryGame');
        }

        /**
         * Helper function to shuffle an array (Fisher-Yates shuffle).
         * @param {Array} array - The array to shuffle.
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }


        /*
        =======================================================================
         9. Module 9: Game Mode - Whac-a-Mole
        =======================================================================
        */

        // Settings specific to Whac-a-Mole
        const WhacSettings = {
            GAME_DURATION: 30000, // 30 seconds
            MIN_PEEP_TIME: 300,   // ms 
            MAX_PEEP_TIME: 1000,  // ms 
            HOLE_COUNT: 9
        };

        // State specific to Whac-a-Mole
        const WhacState = {
            holes: [], // Array of DOM elements
            lastHole: null, // Prevents appearing in the same spot
            peepTimeout: null,
            score: 0,
            scoreDisplay: null
        };

        /**
         * Starts the Whac-a-Mole game.
         */
        function startWhacGame() {
            const D = AppState.DOM;
            const C = AppState.currentGame;
            
            C.gameMode = 'whacAMole';
            
            // Prepare UI
            D.gameContainer.innerHTML = `
                <div class="game-start-screen" id="start-screen-whacAMole">
                     <h2 class="game-title">Whac-a-Mole</h2>
                     <div class="whac-stats-live" style="margin-bottom: 1rem;">
                         Score: <span id="whac-score" style="font-size: 1.5rem; font-weight: bold; color: var(--accent-color);">0</span>
                     </div>
                     <div class="whac-game-grid" id="whac-grid"></div>
                </div>
            `;
            
            // Save references
            const grid = document.getElementById('whac-grid');
            WhacState.scoreDisplay = document.getElementById('whac-score');
            
            // Reset state
            C.isActive = true;
            WhacState.score = 0;
            WhacState.lastHole = null;
            clearTimeout(WhacState.peepTimeout);
            WhacState.scoreDisplay.textContent = '0';
            
            // Create holes
            grid.innerHTML = '';
            WhacState.holes = [];
            for (let i = 0; i < WhacSettings.HOLE_COUNT; i++) {
                const hole = document.createElement('div');
                hole.className = 'whac-hole';
                
                const mole = document.createElement('div');
                mole.className = 'whac-mole';
                mole.addEventListener('click', handleMoleBonk); // Add listener to the mole
                
                hole.appendChild(mole);
                grid.appendChild(hole);
                WhacState.holes.push(hole);
            }
            
            // Start game
            C.startTime = Date.now();
            C.timerInterval = setInterval(updateGameTimer, 100);
            
            // Set game end timer
            setTimeout(stopWhacGame, WhacSettings.GAME_DURATION);
            
            // Start moles peeping
            peepMole();
        }

        /**
         * Ends the Whac-a-Mole game.
         */
        function stopWhacGame() {
            const C = AppState.currentGame;
            if (!C.isActive || C.gameMode !== 'whacAMole') return;
            
            C.isActive = false;
            C.endTime = Date.now();
            clearInterval(C.timerInterval);
            clearTimeout(WhacState.peepTimeout); // Stop moles from peeping
            
            // Show final stats
            C.hits = WhacState.score; // Save score
            showFinalStats('whacAMole');
        }

        /**
         * Random mole peep function.
         */
        function peepMole() {
            const C = AppState.currentGame;
            if (!C.isActive) return;
            
            // Random time for the mole to be visible
            const time = randomTime(WhacSettings.MIN_PEEP_TIME, WhacSettings.MAX_PEEP_TIME);
            // Random hole
            const hole = randomHole(WhacState.holes);
            
            // Show mole
            hole.classList.add('up');
            
            // Set timer to hide the mole
            WhacState.peepTimeout = setTimeout(() => {
                hole.classList.remove('up');
                // Call the next mole if the game is still active
                if (C.isActive) {
                    peepMole();
                }
            }, time);
        }

        /**
         * Returns a random time from the given interval.
         */
        function randomTime(min, max) {
            return Math.round(Math.random() * (max - min) + min);
        }

        /**
         * Returns a random hole, different from the previous one.
         */
        function randomHole(holes) {
            const idx = Math.floor(Math.random() * holes.length);
            const hole = holes[idx];
            
            if (hole === WhacState.lastHole) {
                // If it's the same hole, try again
                return randomHole(holes);
            }
            
            WhacState.lastHole = hole;
            return hole;
        }

        /**
         * Handles hitting a mole.
         * @param {Event} e - The 'click' event.
         */
        function handleMoleBonk(e) {
            if (!AppState.currentGame.isActive) return;
            
            // Check if the mole was actually 'up' (prevents cheating)
            const hole = e.target.parentElement;
            if (!hole.classList.contains('up')) {
                return; // Didn't hit at the right time
            }
            
            WhacState.score++;
            WhacState.scoreDisplay.textContent = WhacState.score;
            
            // Immediately hide the hit mole
            hole.classList.remove('up');
            
            // Update live stats (if desired)
            AppState.currentGame.hits = WhacState.score;
            updateLiveStats();
        }


        /*
        =======================================================================
         10. Module 10: General Logic (Start/Stop, Timers, Stats)
        =======================================================================
        */

        /**
         * Central handler for "Start Game" buttons.
         * @param {Event} e - The 'click' event.
         */
        function handleGameStartClick(e) {
            const gameMode = e.target.dataset.startGame;
            
            // ***************************************************************
            // CRITICAL MONETIZATION IMPLEMENTATION (AD NOTIFICATION)
            // ***************************************************************
            
            // Show ad modal
            openModal('ad-notification-modal');
            
            // Start the game WITH A DELAY, to give time for the ad to display
            // (Alternatively, start the game after the user closes the modal)
            
            // In this case, we start the game immediately after the modal is closed
            const adModal = AppState.DOM.adNotificationModal;
            
            // Function to run the game
            const runGame = () => {
                switch (gameMode) {
                    case 'aimTrainer':
                        startAimTrainer();
                        break;
                    case 'tracking':
                        startTrackingGame();
                        break;
                    case 'whacAMole':
                        startWhacGame();
                        break;
                    // Other games (typing, memory) start differently
                }
                // Remove the listener to avoid firing multiple times
                adModal.removeEventListener('close', runGame);
            };
            
            // Add a listener that runs the game after the modal is closed
            adModal.addEventListener('close', runGame);
        }

        /**
         * Stops any actively running game.
         */
        function stopCurrentGame() {
            const C = AppState.currentGame;
            if (!C.isActive) return;
            
            switch (C.gameMode) {
                case 'aimTrainer':
                    stopAimTrainer();
                    break;
                case 'tracking':
                    stopTrackingGame();
                    break;
                case 'typingTest':
                    stopTypingTest();
                    break;
                case 'memoryGame':
                    // Memory game has no timer, but it does end
                    // stopMemoryGame(); // Is called internally
                    break;
                case 'whacAMole':
                    stopWhacGame();
                    break;
            }
            
            C.isActive = false;
            C.gameMode = null;
            clearInterval(C.timerInterval);
        }

        /**
         * Updates the game timer in the sidebar.
         */
        function updateGameTimer() {
            const C = AppState.currentGame;
            if (!C.isActive || C.startTime === 0) return;
            
            const D = AppState.DOM.liveStats;
            const elapsedTime = (Date.now() - C.startTime) / 1000;
            D.timer.textContent = `${elapsedTime.toFixed(1)}s`;
        }

        /**
         * Updates the live stats in the sidebar.
         */
        function updateLiveStats() {
            const C = AppState.currentGame;
            const D = AppState.DOM.liveStats;
            
            let accuracy = 0;
            const totalActions = C.hits + C.misses;
            
            if (C.gameMode === 'tracking') {
                // For Tracking, 'hits' is time on target, 'misses' is time off
                D.hits.textContent = (C.hits / 1000).toFixed(1) + 's';
                D.misses.textContent = (C.misses / 1000).toFixed(1) + 's';
                if (totalActions > 0) {
                    accuracy = (C.hits / totalActions) * 100;
                }
                D.accuracy.textContent = `${accuracy.toFixed(1)}%`;
                
            } else if (C.gameMode === 'whacAMole') {
                D.hits.textContent = C.hits; // 'hits' is score
                D.misses.textContent = 'N/A';
                D.accuracy.textContent = 'N/A';
                
            } else if (C.gameMode === 'aimTrainer') {
                // For Aim Trainer
                D.hits.textContent = C.hits;
                D.misses.textContent = C.misses;
                if (totalActions > 0) {
                    accuracy = (C.hits / totalActions) * 100;
                }
                D.accuracy.textContent = `${accuracy.toFixed(1)}%`;
                
            } else {
                // Default behavior (for future games)
                D.hits.textContent = C.hits;
                D.misses.textContent = C.misses;
                D.accuracy.textContent = 'N/A';
            }
        }

        /**
         * Resets the live stats in the sidebar.
         */
        function resetLiveStats() {
            const D = AppState.DOM.liveStats;
            D.hits.textContent = '0';
            D.misses.textContent = '0';
            D.accuracy.textContent = '0%';
            D.timer.textContent = '0.0s';
        }

        /**
         * Calculates and displays the final stats in the modal.
         * @param {string} gameMode - ID of the completed game.
         */
        function showFinalStats(gameMode) {
            const C = AppState.currentGame;
            const D = AppState.DOM;
            
            let title = 'Game Over!';
            let bodyHtml = '';
            let newHighScore = false;
            let scoreData = {};
            
            // Prepare stats for each game
            switch (gameMode) {
                case 'aimTrainer':
                    const avgReaction = calculateAverageReactionTime();
                    const finalCps = calculateFinalCPS();
                    const accuracy = (C.hits + C.misses > 0) ? ((C.hits / (C.hits + C.misses)) * 100).toFixed(1) : 0;
                    
                    title = 'Aim Trainer: Results';
                    bodyHtml = `
                        <p>Average reaction time: <strong>${avgReaction} ms</strong></p>
                        <p>Hits: <strong>${C.hits}</strong></p>
                        <p>Misses: <strong>${C.misses}</strong></p>
                        <p>Accuracy: <strong>${accuracy}%</strong></p>
                        <p>Average CPS: <strong>${finalCps}</strong></p>
                    `;
                    
                    // Check for high score
                    scoreData = { score: C.hits, reaction: avgReaction };
                    if (!AppState.highScores.aimTrainer || C.hits > AppState.highScores.aimTrainer.score) {
                        newHighScore = true;
                        saveHighScore('aimTrainer', scoreData);
                    }
                    break;
                    
                case 'tracking':
                    const totalTime = C.hits + C.misses;
                    const trackingAccuracy = (totalTime > 0) ? ((C.hits / totalTime) * 100) : 0;
                    
                    title = 'Tracking: Results';
                    bodyHtml = `
                        <p>Time on target: <strong>${(C.hits / 1000).toFixed(2)} s</strong></p>
                        <p>Time off target: <strong>${(C.misses / 1000).toFixed(2)} s</strong></p>
                        <p>Tracking Accuracy: <strong>${trackingAccuracy.toFixed(2)}%</strong></p>
                    `;
                    
                    scoreData = { score: trackingAccuracy };
                    if (!AppState.highScores.tracking || trackingAccuracy > AppState.highScores.tracking.score) {
                        newHighScore = true;
                        saveHighScore('tracking', scoreData);
                    }
                    break;
                    
                case 'typingTest':
                    const wpm = C.hits; // We stored WPM in C.hits
                    const errors = C.misses;
                    const typingAccuracy = C.accuracy || 100;
                    
                    title = 'Typing Test: Results';
                    bodyHtml = `
                        <p>Words Per Minute (WPM): <strong>${wpm}</strong></p>
                        <p>Error count: <strong>${errors}</strong></p>
                        <p>Accuracy: <strong>${typingAccuracy}%</strong></p>
                    `;
                    
                    scoreData = { wpm: wpm, accuracy: typingAccuracy };
                    if (!AppState.highScores.typingTest || wpm > AppState.highScores.typingTest.wpm) {
                        newHighScore = true;
                        saveHighScore('typingTest', scoreData);
                    }
                    break;
                    
                case 'memoryGame':
                    const moves = C.hits; // We stored moves in C.hits
                    title = 'Memory Game: Results';
                    bodyHtml = `
                        <p>Game complete!</p>
                        <p>Total moves: <strong>${moves}</strong></p>
                    `;
                    
                    scoreData = { moves: moves };
                    if (!AppState.highScores.memoryGame || moves < AppState.highScores.memoryGame.moves) {
                        newHighScore = true;
                        saveHighScore('memoryGame', scoreData);
                    }
                    break;
                    
                case 'whacAMole':
                    const score = C.hits; // We stored the score in C.hits
                    title = 'Whac-a-Mole: Results';
                    bodyHtml = `
                        <p>Game Over!</p>
                        <p>Final score: <strong>${score}</strong></p>
                    `;
                    
                    scoreData = { score: score };
                    if (!AppState.highScores.whacAMole || score > AppState.highScores.whacAMole.score) {
                        newHighScore = true;
                        saveHighScore('whacAMole', scoreData);
                    }
                    break;
            }
            
            // Fill and show the modal
            D.statsModalTitle.textContent = title;
            D.statsModalBody.innerHTML = bodyHtml;
            D.statsModalNewHighScore.hidden = !newHighScore;
            
            openModal('stats-modal');
        }

        /*
        =======================================================================
         11. Module 11: Application Initialization (Main Loop)
        =======================================================================
        */

        /**
         * Main function to initialize the application.
         * Called after the DOM tree is loaded.
         */
        function initializeApp() {
            console.log("Initializing ReflexCore v1.0...");
            
            // 1. Map all DOM elements
            initializeDOMSelectors();
            
            // 2. Load settings (theme, language) from localStorage
            loadSettings();
            
            // 3. Load high scores
            loadHighScores();
            
            // 4. Start listeners for the settings panel
            initializeSettingsPanel();
            
            // 5. Start listeners for navigation
            initializeNavigation();
            
            // 6. Start listeners for modal windows
            initializeModals();
            
            console.log("Application ready.");
        }

        // Run the application after the HTML structure is fully loaded
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>

</body>
</html>
